TRUE * 1
FALSE * 1
knitr::opts_chunk$set(echo = TRUE)
observations <- f + rnorm(length(x), mean = 0, sd = 15)
set.seed(123)
library(ggplot2)
true_relationship <- function(x) { return(6*xˆ3 + 6*xˆ2 - 12*x) }
x <- seq(-3, 2, by = 0.1)
f <- true_relationship(x)
true_relationship <- function(x) { return(6*xˆ3 + 6*xˆ2 - 12*x) }
#set.seed(123)
library(ggplot2)
true_relationship <- function(x) { return(6*xˆ3 + 6*xˆ2 - 12*x) }
x <- seq(-3, 2, by = 0.1)
f <- true_relationship(x)
View(true_relationship)
set.seed(123)
library(ggplot2)
true_relationship <- function(x) {
return(6*x^3 + 6*x^2 - 12*x)
}
x <- seq(-3, 2, by = 0.1)
f <- true_relationship(x)
ggplot() + geom_line(aes(x = x, y = f), color = "black")
knitr::opts_chunk$set(echo = TRUE)
observations <- f + rnorm(length(x), mean = 0, sd = 15)
model1 <- lm(observations ~ poly(x, 1))
predictions1 <- predict(model1, newdata = data.frame(x = x))
model25 <- lm(observations ~ poly(x, 25))
predictions25 <- predict(model25, newdata = data.frame(x = x))
data <- data.frame(x = x,
f = f,
observations = observations,
lm = predictions1,
pm = predictions25)
ggplot(data, aes(x = x)) +
geom_line(aes(y = f), color = "black") +
geom_point(aes(y = observations), color = "blue", shape = 1) +
geom_line(aes(y = lm), color = "red", linetype = "solid") +
geom_line(aes(y = pm), color = "orange", linetype = "solid") +
geom_point(aes(x = 1, y = data[x == 1, "lm"]), color = "red", shape=2) +
geom_point(aes(x = 1, y = data[x == 1, "pm"]), color = "orange", shape=2)
observations_new <- f + rnorm(length(x), mean = 0, sd = 15)
model1 <- lm(observations_new ~ poly(x, 1))
predictions1 <- predict(model1, newdata = data.frame(x = x))
model25 <- lm(observations_new ~ poly(x, 25))
predictions25 <- predict(model25, newdata = data.frame(x = x))
data <- data.frame(x = x,
f = f,
observations = observations_new,
lm = predictions1,
pm = predictions25)
ggplot(data, aes(x = x)) +
geom_line(aes(y = f), color = "black") +
geom_point(aes(y = observations_new), color = "blue", shape = 1) +
geom_line(aes(y = lm), color = "red", linetype = "solid") +
geom_line(aes(y = pm), color = "orange", linetype = "solid") +
geom_point(aes(x = 1, y = data[x == 1, "lm"]), color = "red", shape=2) +
geom_point(aes(x = 1, y = data[x == 1, "pm"]), color = "orange", shape=2)
results1 <- data.frame(x = 1, f_pred = 0)
for (i in 1:500) {
x <- seq(-3, 2, by = 0.1)
f <- true_relationship(x)
temp_observations <- f + rnorm(length(x), mean=0, sd=15)
model1 <- lm(temp_observations ~ poly(x, 1))
results1[i, 1] <- 1
results1[i, 2] <- predict(model1, newdata = data.frame(x=1))
}
ggplot() +
geom_line(data = data, aes(x = x, y = f), color = "black") +
geom_point(data = results1, aes(x = x, y = f_pred), color="red", shape=2)
results20 <- data.frame(x = 1, f_pred = 0)
for (i in 1:500) {
x <- seq(-3, 2, by = 0.1)
f <- true_relationship(x)
temp_observations <- f + rnorm(length(x), mean=0, sd=15)
model20 <- lm(temp_observations ~ poly(x, 20))
results20[i, 1] <- 1
results20[i, 2] <- predict(model20, newdata = data.frame(x=1))
}
ggplot() +
geom_line(data = data, aes(x = x, y = f), color = "black") +
geom_point(data = results20, aes(x = x, y = f_pred), color="orange", shape=2)
models <- vector("list", 25)
for (degree in 1:25) {
model <- lm(observations ~ poly(x, degree))
models[[degree]] <- model
}
results <- data.frame(degree = 1:25, rmse = 0)
for (degree in 1:25) {
predictions <- predict(models[[degree]], newdata = data.frame(x=x))
results[results$degree==degree, "rmse"] <-
sqrt((1/length(predictions))*sum((predictions-observations)ˆ2))
knitr::opts_chunk$set(echo = TRUE)
models <- vector("list", 25)
for (degree in 1:25) {
model <- lm(observations ~ poly(x, degree))
models[[degree]] <- model
}
results <- data.frame(degree = 1:25, rmse = 0)
for (degree in 1:25) {
predictions <- predict(models[[degree]], newdata = data.frame(x=x))
results[results$degree==degree, "rmse"] <-
sqrt((1/length(predictions))*sum((predictions-observations)^2))
}
ggplot() +
geom_line(data = results, aes(x = degree, y = rmse), color = "black")
results <- data.frame(degree = 1:25, rmse = 0)
for (degree in 1:25) {
predictions <- predict(models[[degree]], newdata = data.frame(x=x))
results[results$degree==degree, "rmse"] <-
sqrt((1/length(predictions))*sum((predictions-observations_new)^2))
}
ggplot() +
geom_line(data = results, aes(x = degree, y = rmse), color = "black")
View(results20)
View(models)
knitr::opts_chunk$set(echo = TRUE)
model <- lm(observations ~ poly(x, 4))
predictions=predict(model, newdata = data.frame(x=x))
data = data.frame(x=x, f=f, predictions=predictions)
ggplot(data, aes(x=x)) +
geom_line(aes(y = f), color = "black") +
geom_line(aes(y = predictions), color = "red", linetype="solid")
library(keras)
library(reticulate)
library(tensorflow)
tensorflow::tf_config()
use_virtualenv("my_tf_workspace")
library(keras)
library(reticulate)
library(tensorflow)
use_virtualenv("my_tf_workspace")
tensorflow::tf_config()
setwd("C:/Users/janna/Documents/Merrimack MSDS/team-beta")
library(tidyr)
library(dplyr)
library(stringr)
library(codebookr)
dataset_folder <- paste(getwd(),"/datasets",sep="")
all_csv <- list.files(path = dataset_folder, pattern = "\\.csv$", full.names = TRUE)
csv_list <- lapply(all_csv, read.csv)
names(csv_list) <- tools::file_path_sans_ext(basename(all_csv))
# Function to rename columns based on first row values
rename_columns <- function(df) {
cols_to_rename <- colnames(df)[colnames(df) != "Year"]  # Identify columns to rename
colnames(df)[colnames(df) != "Year"] <- as.character(df[1, cols_to_rename])  # Rename to first value in the column
# Handle NA or empty string column names
colnames(df)[is.na(colnames(df))] <- paste0("missing", which(is.na(colnames(df))))
colnames(df)[colnames(df) == ""] <- paste0("missing",which(colnames(df) == ""))
return(df[-1, ])  # Remove first row after renaming
}
drop_na_cols <- function(df) {
df <- df[, colSums(is.na(df)) < nrow(df)]
}
get_unique_columns <- function(df_list) {
# Extract column names from all dataframes and combine them into one vector
all_columns <- unlist(lapply(df_list, colnames))
# Get unique column names
unique_columns <- unique(all_columns)
return(unique_columns)
}
# Function to add missing columns to any dataframe in df_list
add_missing_columns <- function(df_list, columns_to_add) {
# Iterate through each dataframe in the list
df_list <- lapply(df_list, function(df) {
# Check for columns that are missing
missing_columns <- setdiff(columns_to_add, colnames(df))
# Add missing columns with NA values
for (col in missing_columns) {
df[[col]] <- NA  # You can change `NA` to any default value if needed
}
return(df)
})
return(df_list)
}
get_common_columns <- function(df_list) {
common_cols <- Reduce(intersect, lapply(df_list, colnames))
return(common_cols)
}
remove_non_observations <- function(df) {
bad_values <- c("Tm","","League Average")
df <- df %>%
filter(!(Tm %in% bad_values))
return(df)
}
current_csv <- csv_list[[1]]
# Find all indices where the first col = "Tm"
# Use this to split the csv file into different dataframes
tm_indices <- which(current_csv[[1]] == "Tm")
# Initialize a list to store the split dataframes
df_list <- list()
# Loop through "Tm" indices to extract dataframes for each season
for (i in seq_along(tm_indices)) {
start_idx <- tm_indices[i]  # Start from "Tm"
# Determine end index (either next "Tm" or end of dataframe)
end_idx <- ifelse(i < length(tm_indices), tm_indices[i + 1] - 1, nrow(current_csv))
# Extract the subset and store in list
df_list[[paste0("df_", i)]] <- current_csv[start_idx:end_idx, ]
}
# Filter out dataframes with less than 2 rows
# Column names are written again at the end of each season so this line removes those rows
df_list <- df_list[sapply(df_list, nrow) >= 2]
# Apply rename_columns function to every dataframe in the list
df_list <- lapply(df_list, rename_columns)
# Drop columns that have all NA values
df_list <- lapply(df_list, drop_na_cols)
# Get vector of all unique column names to pass through the add_missing_columns function
columns_to_add <- get_unique_columns(df_list)
# Apply the function to the list of dataframes
df_list <- add_missing_columns(df_list, columns_to_add)
# Get the common columns between all dataframes to use in full join
common_columns <- get_common_columns(df_list)
# Perform a full join on all dataframes based on the common columns
df_full_joined <- Reduce(function(x, y) full_join(x, y, by = common_columns), df_list)
df_full_joined <- remove_non_observations(df_full_joined)
csv_list[[1]] <- df_full_joined
write.csv(df_full_joined, file = paste(getwd(),"/cleaned_data/","cleaned_",names(csv_list)[1],".csv",sep = ""))
names(csv_list)[1]
################################################################################
current_csv <- csv_list[[2]]
# Find all indices where the first col = "Tm"
# Use this to split the csv file into different dataframes
tm_indices <- which(current_csv[[1]] == "Tm")
# Initialize a list to store the split dataframes
df_list <- list()
# Loop through "Tm" indices to extract dataframes for each season
for (i in seq_along(tm_indices)) {
start_idx <- tm_indices[i]  # Start from "Tm"
# Determine end index (either next "Tm" or end of dataframe)
end_idx <- ifelse(i < length(tm_indices), tm_indices[i + 1] - 1, nrow(current_csv))
# Extract the subset and store in list
df_list[[paste0("df_", i)]] <- current_csv[start_idx:end_idx, ]
}
# Filter out dataframes with less than 2 rows
# Column names are written again at the end of each season so this line removes those rows
df_list <- df_list[sapply(df_list, nrow) >= 2]
# Apply rename_columns function to every dataframe in the list
df_list <- lapply(df_list, rename_columns)
# Drop columns that have all NA values
df_list <- lapply(df_list, drop_na_cols)
# Get vector of all unique column names to pass through the add_missing_columns function
columns_to_add <- get_unique_columns(df_list)
# Apply the function to the list of dataframes
df_list <- add_missing_columns(df_list, columns_to_add)
# Get the common columns between all dataframes to use in full join
common_columns <- get_common_columns(df_list)
# Perform a full join on all dataframes based on the common columns
df_full_joined <- Reduce(function(x, y) full_join(x, y, by = common_columns), df_list)
df_full_joined <- remove_non_observations(df_full_joined)
csv_list[[2]] <- df_full_joined
write.csv(df_full_joined, file = paste(getwd(),"/cleaned_data/","cleaned_",names(csv_list)[2],".csv",sep = ""))
names(csv_list)[2]
current_csv <- csv_list[[3]]
test <- remove_non_observations(current_csv)
View(test)
for (i in 3:length(csv_files)) {
csv_files[[i]] <- remove_non_observations(csv_files[[i]])
write.csv(df_full_joined, file = paste(getwd(),"/cleaned_data/","cleaned_",names(csv_list)[i],".csv",sep = ""))
}
for (i in 3:length(csv_list)) {
csv_list[[i]] <- remove_non_observations(csv_list[[i]])
write.csv(df_full_joined, file = paste(getwd(),"/cleaned_data/","cleaned_",names(csv_list)[i],".csv",sep = ""))
}
